<!DOCTYPE html>
<html>
  <head>
    <title>Verifiable Credentials Implementation Guidelines 1.0</title>
    <meta http-equiv='Content-Type' content='text/html;charset=utf-8'/>
    <!--
      === NOTA BENE ===
      For the three scripts below, if your spec resides on dev.w3 you can check them
      out in the same tree and use relative links so that they'll work offline,
     -->
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common' class='remove'></script>
    <script src="./common.js" class="remove"></script>
    <script type="text/javascript" class="remove">
      var respecConfig = {
        // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
        specStatus: "ED",

        // the specification's short name, as in http://www.w3.org/TR/short-name/
        shortName: "vc-imp-guide",

        // subtitle for the spec
        subtitle: "Implementation guidance for Verifiable Credentials",

        // if you wish the publication date to be other than today, set this
        //publishDate:  "2017-08-03",

        // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
        // and its maturity status
        // previousPublishDate:  "1977-03-15",
        // previousMaturity:  "WD",

        // extend the bibliography entries
        localBiblio: vcwg.localBiblio,
        doJsonLd: true,

        github: "https://github.com/w3c/vc-imp-guide",
        includePermalinks: false,

        // if there a publicly available Editor's Draft, this is the link
        edDraftURI: "https://w3c.github.io/vc-imp-guide/",

        // if this is a LCWD, uncomment and set the end of its review period
        // lcEnd: "2009-08-05",

        // editors, add as many as you like
        // only "name" is required
        editors:  [{ name: "Andrei Sambra", url: "https://deiu.me/"}],

        // authors, add as many as you like.
        // This is optional, uncomment if you have authors as well as editors.
        // only "name" is required. Same format as editors.
        authors: [{
          name: "Manu Sporny", url: "http://manu.sporny.org/",
          company: "Digital Bazaar", companyURL: "http://digitalbazaar.com/"
        }],

        // name of the WG
        wg:           "Verifiable Claims Working Group",

        // URI of the public WG page
        wgURI:        "https://www.w3.org/2017/vc/",

        // name (with the @w3c.org) of the public mailing to which comments are due
        wgPublicList: "public-vc-comments",

        // URI of the patent status for this WG, for Rec-track documents
        // !!!! IMPORTANT !!!!
        // This is important for Rec-track documents, do not copy a patent URI from a random
        // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
        // Team Contact.
        wgPatentURI:  "https://www.w3.org/2004/01/pp-impl/98922/status",
        maxTocLevel: 4,
        inlineCSS: true
      };
    </script>
    <style>
pre .highlight {
  font-weight: bold;
  color: green;
}
pre .subject {
  font-weight: bold;
  color: RoyalBlue;
}
pre .property {
  font-weight: bold;
  color: DarkGoldenrod;
}
pre .comment {
  font-weight: bold;
  color: Gray;
}
.supported {
  background-color: #93c47d;
}
.missing {
  background-color: #e06666;
}
</style>
  </head>
  <body>
    <section id='abstract'>
      <p>
This document provides implementation guidance for Verifiable Credentials.
      </p>
    </section>

    <section id='sotd'>
      <p>
Comments regarding this document are welcome. Please file issues
directly on <a href="https://github.com/w3c/vc-data-model/issues/">GitHub</a>,
or send them to
<a href="mailto:public-vc-comments@w3.org">public-vc-comments@w3.org</a>
(<a href="mailto:public-vc-comments-request@w3.org?subject=subscribe">subscribe</a>,
<a href="https://lists.w3.org/Archives/Public/public-vc-comments/">archives</a>).
      </p>
    </section>

    <section>
      <h2>Introduction</h2>
      <em>This section is non-normative.</em>

      <p>
        Welcome dear implementer of Verifiable Credentials! We understand that reading 
        and nagivating technical specifications can be confusing at times. For this reason, 
        we would like to offer you a few resources to get you started.
      </p>
      <p>
        First, you should probably become familiarized with the official 
        <a href="https://www.w3.org/TR/verifiable-claims-use-cases/">Use Cases document</a>, 
        which offers a concise but limited collection of use cases readers should review before
        undestanding how Verifiable Claims can best help them.
      </p>
      <p>
        The <a href="https://w3c.github.io/vc-data-model/">data model specification</a> is the 
        most important result of two years of hard work done by the Verifiable Claims Working Group.
        However, the data model itself is not sufficient if you plan to use Verifiable Claims today.
        Additional works needs to be done on identifiers as well as on proofs, as you will be able to
        find out in the sections below. 
      </p>
    </section>

    <section>
      <h2>Identifiers</h2>
      <em>This section is non-normative.</em>
      <p>
          When expressing statements about a specific entity, such as a person, product, or organization, 
          it is often useful to use some kind of identifier so that others can express statements about 
          the same thing. You may have noticed that the VC Data Model specification contains numerous 
          examples where the choice of identifier for the subject of the credential (the thing the claims 
          are about) has been a <a href="https://w3c-ccg.github.io/did-primer/">decentralized identifier</a>, 
          also known as a DID. An example of a DID is <code>did:example:123456abcdef</code>.
      </p>
      <p class="note">
          As of the publication of the VC Data Model specification, DIDs are a new type of identifier that 
          are not necessary for verifiable credentials to be useful. Specifically, verifiable credentials 
          do not depend on DIDs and DIDs do not depend on verifiable credentials. However, it is expected 
          that many verifiable credentials will use DIDs and that software libraries implementing the Data Model 
          specification will probably need to resolve DIDs. DID-based URLs are used for expressing identifiers 
          associated with subjects, issuers, holders, credential status lists, cryptographic keys, and other 
          machine-readable information that is associated with a verifiable credential. 
      </p>
      
      <p>
        There is currently a proposed charter for a new <a href="https://w3c-ccg.github.io/did-wg-charter/">
        Decentralized Identifier Working Group</a> that has been submitted to the W3C, aiming to officially 
        put DIDs on the standards track.
      </p>
    </section>

    <section>
      <h2>Proofs</h2>
      <em>This section is non-normative.</em>

      <p>
          The VC Data Model is designed to be proof format agnostic. At the time of publication, 
          at least two proof formats are being actively utilized by implementers -- JSON Web Token (JWT)
          and Linked Data Proofs.
          The Working Group felt that <a href="https://w3c.github.io/vc-data-model/#proof-formats">documenting</a> 
          in the spec what these proof formats are and how they are being used would be beneficial to implementers.
          
      </p>
      <p>
        The table below compares three syntax and proof format ecosystems; JSON+JWTs, JSON-LD+JWTs, 
        and JSON-LD+LD-Proofs. Implementers should be aware that Zero-Knowledge Proofs are currently 
        proposed as a sub-type of LD-Proofs and thus fall into the final column below.
      </p>

      <table class="simple">
        <thead>
          <tr>
            <th style="text-align: center;">Feature</th>
            <th style="text-align: center;">JSON<br>+<br>JWTs</th>
            <th style="text-align: center;">JSON&#8209;LD<br>+<br>JWTs</th>
            <th style="text-align: center;">JSON&#8209;LD<br>+<br>LD&#8209;Proofs</th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td>
              <a href="#pf1">PF1.</a> Support for open world data modelling.
            </td>
            <td class="missing">✖</td>
            <td class="supported">✓</td>
            <td class="supported">✓</td>
          </tr>
          <tr>
            <td>
  <a href="#pf2">PF2.</a> Universal identifier mechanism for JSON objects via
  the use of URIs.
            </td>
            <td class="missing">✖</td>
            <td class="supported">✓</td>
            <td class="supported">✓</td>
          </tr>
          <tr>
            <td>
  <a href="#pf3">PF3.</a> A way to disambiguate properties shared among different
  JSON documents by mapping them to IRIs via a context.
            </td>
            <td class="missing">✖</td>
            <td class="supported">✓</td>
            <td class="supported">✓</td>
          </tr>
          <tr>
            <td>
  <a href="#pf4">PF4.</a> A mechanism to refer to data in an external document,
  where the data may be merged with the local document without a merge conflict
  in semantics or structure.
            </td>
            <td class="missing">✖</td>
            <td class="supported">✓</td>
            <td class="supported">✓</td>
          </tr>
          <tr>
            <td>
  <a href="#pf5">PF5.</a> The ability to annotate strings with their language.
            </td>
            <td class="missing">✖</td>
            <td class="supported">✓</td>
            <td class="supported">✓</td>
          </tr>
          <tr>
            <td>
  <a href="#pf6">PF6.</a> A way to associate arbitrary datatypes, such as dates
  and times, with arbitrary property values.
            </td>
            <td class="missing">✖</td>
            <td class="supported">✓</td>
            <td class="supported">✓</td>
          </tr>
          <tr>
            <td>
  <a href="#pf7">PF7.</a> A facility to express one or more directed graphs,
  such as a social network, in a single document.
            </td>
            <td class="missing">✖</td>
            <td class="supported">✓</td>
            <td class="supported">✓</td>
          </tr>
          <tr>
            <td>
  <a href="#pf8">PF8.</a> Supports signature sets.
            </td>
            <td class="missing">✖</td>
            <td class="missing">✖</td>
            <td class="supported">✓</td>
          </tr>
          <tr>
            <td>
  <a href="#pf9">PF9.</a> Embeddable in HTML such that search crawlers will
  index the machine-readable content.
            </td>
            <td class="missing">✖</td>
            <td class="missing">✖</td>
            <td class="supported">✓</td>
          </tr>
          <tr>
            <td>
  <a href="#pf10">PF10.</a> Data on the wire is easy to debug and serialize to
  database systems.
            </td>
            <td class="missing">✖</td>
            <td class="missing">✖</td>
            <td class="supported">✓</td>
          </tr>

          <tr>
            <td>
  <a href="#pf11">PF11.</a> Nesting signed data does not cause data size to
  double for every embedding.
            </td>
            <td class="missing">✖</td>
            <td class="missing">✖</td>
            <td class="supported">✓</td>
          </tr>

          <tr>
            <td>
  <a href="#pf12">PF12.</a> Proof format supports Zero-Knowledge Proofs.
            </td>
            <td class="missing">✖</td>
            <td class="missing">✖</td>
            <td class="supported">✓</td>
          </tr>

          <tr>
            <td>
  <a href="#pf13">PF13.</a> Proof format supports arbitrary proofs such as Proof
  of Work, Timestamp Proofs, and Proof of Stake.
            </td>
            <td class="missing">✖</td>
            <td class="missing">✖</td>
            <td class="supported">✓</td>
          </tr>

          <tr>
            <td>
  <a href="#pf14">PF14.</a> Proofs can be expressed unmodified in other data
  syntaxes such as YAML, N-Quads, and CBOR.
            </td>
            <td class="missing">✖</td>
            <td class="missing">✖</td>
            <td class="supported">✓</td>
          </tr>

          <tr>
            <td>
  <a href="#pf15">PF15.</a> Signature is not invalidated by changes in whitespace 
  or in the ordering of property-values.
            </td>
            <td class="missing">✖</td>
            <td class="missing">✖</td>
            <td class="supported">✓</td>
          </tr>

          <tr>
            <td>
  <a href="#pf16">PF16.</a> Designed to easily support experimental signature
  systems.
            </td>
            <td class="missing">✖</td>
            <td class="missing">✖</td>
            <td class="supported">✓</td>
          </tr>

          <tr>
            <td>
  <a href="#pf17">PF17.</a> Supports signature chaining.
            </td>
            <td class="missing">✖</td>
            <td class="missing">✖</td>
            <td class="supported">✓</td>
          </tr>

          <tr>
            <td>
  <a href="#pf18">PF18.</a> Does not require pre-processing or post-processing.
            </td>
            <td class="missing">✖</td>
            <td class="missing">✖</td>
            <td class="supported">✓</td>
          </tr>

          <tr>
            <td>
  <a href="#pf19">PF19.</a> Canonicalization does not require more than base-64 encoding.
            </td>
            <td class="missing">✖</td>
            <td class="missing">✖</td>
            <td class="supported">✓</td>
          </tr>
        </tbody>
      </table>
      
      <p class="note">
          Some of the features listed in the table above are debateable since a feature
          can always be added to a particular syntax or digital proof format. The table
          is intended to identify native features of each combination such that no
          additional language design or extension is required to achieve the identified
          feature. Features that all languages provide, such as the ability to express
          numbers, have not been included for the purposes of brevity.
      </p>
          
      <dl>
        <dt id="pf1">
          PF1: Support for open world data modelling
                </dt>
                <dd>
          An <em>open world data model</em> is one where any entity can make any
          statement about anything while simultaneously ensuring that the semantics of
          the statement are unambiguous. This specification is enabled by an open world
          data model called Linked Data. One defining characteristic of supporting an open
          world data model is the ability to specify the semantic context in which data
          is being expressed. JSON-LD provides this mechanism via the
          <code>@context</code> property. JSON has no such feature.
                </dd>
                <dt id="pf2">
          PF2: Universal identifier mechanism for JSON objects via the use of URIs.
                </dt>
                <dd>
          All entities in a JSON-LD document are identified either via an automatic URI,
          or via an explicit URI. This enables all entities in a document to be
          unambiguously referenced. JSON does not have a native URI type nor does it
          require objects to have one, making it difficult to impossible to unambiguously
          identify an entity expressed in JSON.
                </dd>
                <dt id="pf3">
          PF3: A way to disambiguate properties shared among different JSON documents by
          mapping them to IRIs via a context.
                </dt>
                <dd>
          JSON object properties are not mapped to IRIs, which result in ambiguities with
          respect to the semantic meaning of the property. For example, one JSON document
          can use "title" (meaning "book title") in a way that is semantically
          incompatible with another JSON document using "title" (meaning "job title").
          In contrast, each object property in a JSON-LD document, such as the property 
          "homepage", is either a keyword, an IRI, or a literal mapped to an IRI via a context. 
          This feature enables open world systems to identify the semantic meaning of the 
          property in an unambiguous way, which enables seamless merging of data between 
          disparate systems.
          
                </dd>
                <dt id="pf4">
          PF4: A mechanism to refer to data in an external document, whereby the external data may
          be merged with the local document without a merge conflict in semantics or
          structure.
                </dt>
                <dd>
          JSON-LD provides a mechanism that enables a data value to use a URL to refer
          to data outside of the local document. This external data may then be
          automatically merged with the local document without a merge conflict in
          semantics or structure. This feature enables a system to apply the
          "follow your nose" principle to discover a richer set of data that is
          associated with the local document. While a JSON document can contain pointers
          to external data, interpreting the pointer is often application specific and
          usually does not support merging the external data to construct a richer data
          set.
                </dd>
                <dt id="pf5">
          PF5: The ability to annotate strings with their language.
                </dt>
                <dd>
          JSON-LD enables a developer to specify the language, such as English, French,
          or Japanese, in which a text string is expressed via the use of language tags.
          JSON does not provide such a feature.
                </dd>
                <dt id="pf6">
          PF6: A way to associate arbitrary datatypes, such as dates
          and times, with arbitrary property values.
                </dt>
                <dd>
          JSON-LD enables a developer to specify the data type of a property value,
          such as Date, unsigned integer, or Temperature by specifying it in the
          JSON-LD Context. JSON does not provide such a feature.
                </dd>
                <dt id="pf7">
          PF7: A facility to express one or more directed graphs, such as a social
          network, in a single document.
                </dt>
                <dd>
          JSON-LD's abstract data model supports the expression of information
          as a directed graph of labeled nodes and edges, which enables an open world
          data model to be supported. JSON's abstract data model only supports the
          expression of information as a tree of unlabeled nodes and edges, which
          restricts the types of relationships and structures that can be natively
          expressed in the language.
                </dd>
                <dt id="pf8">
          PF8: Supports signature sets.
                </dt>
                <dd>
          A signature set is an unordered set of signatures over a data payload. Use
          cases, such as cryptographic signatures applied to a legal contract,
          typically require more than one signature to be associated with the contract
          in order to legally bind two or more parties under the terms of the contract.
          LD-Proofs, including LD-Signatures, natively support sets of
          signatures. JWTs only enable a single signature over a single payload.
                </dd>
                <dt id="pf9">
          PF9: Embeddable in HTML such that search crawlers will index the
          machine-readable content.
                </dt>
                <dd>
          All major search crawlers natively parse and index information expressed as
          JSON-LD in HTML pages. LD-Proofs enable the current data format that search
          engines use to be extended to support digital signatures. JWTs have no mechanism
          to express data in HTML pages and are currently not indexed by search crawlers.
                </dd>
                <dt id="pf10">
          PF10: Data on the wire is easy to debug and serialize to database systems.
                </dt>
                <dd>
          When developers are debugging software systems, it is beneficial for them to be
          able to see the data that they are operating on using common debugging tools.
          Similarly, it is useful to be able to serialize data from the network to a
          database and then from the database back out to the network using a minimal
          number of pre- and post-processing steps. LD-Proofs enable developers to use
          common JSON tooling without having to convert the format into a different
          format or structure. Payload information in JWTs is base-64 encoded, and requires
          complicated pre- and post-processing steps to convert the data into JSON data
          while not destroying the digital signature. Similarly, schema-less databases,
          which are typically used to index JSON data, cannot index information
          that is expressed in an opaque base-64 encoded wrapper.
                </dd>
                <dt id="pf11">
          PF11: Nesting signed data does not cause data size to double for every
          embedding.
                </dt>
                <dd>
          When a JWT is encapsulated by another JWT, the entire payload must be base-64
          encoded in the initial JWT, and then base-64 encoded again in the encapsulating
          JWT. This is often necessary when a cryptographic signature is required on a
          document that contains a cryptographic signature, such as when a Notary
          signs a document that has been signed by someone else seeking the Notary's
          services. LD-Proofs use an equally secure canonicalization process that requires 
          only the cryptographic signature to be base-64 encoded; i.e., LD-Proofs do 
          not require that the signed portion of a document also be base-64 encoded.
                </dd>
                <dt id="pf12">
          PF12: Proof format supports Zero-Knowledge Proofs.
                </dt>
                <dd>
          The LD-Proof format is capable of specifying the algorithm (including 
          as-yet-undefined algorithms) used to generate the hash or hashes that are 
          cryptographically signed. This cryptographic agility enables digital signature
          systems, such as Zero-Knowledge Proofs, to be layered on top of LD-Proofs 
          without requiring creation of an entirely new digital signature container format.
          Because of the way that JWTs are designed, an entirely new digital signature 
          container format will be required for JWTs to support Zero-Knowledge Proofs.
                </dd>
                <dt id="pf13">
          PF13: Proof format supports arbitrary proofs such as Proof of Work, Timestamp
          Proofs, and Proof of Stake.
                </dt>
                <dd>
          The LD-Proof format was designed with a broad range of proof types in mind
          and supports cryptographic proofs beyond simple cryptographic signatures.
          These proof types are in common use in systems such as decentralized ledgers
          and provide additional guarantees to <a>verifiable credentials</a>, such as 
          the ability to prove that a particular claim was made at a particular time or 
          that a certain amount of energy was expended to generate a particular credential.
          The JWT format does not support arbitrary proof formats.
                </dd>
                <dt id="pf14">
          PF14: Proofs can be expressed unmodified in other data syntaxes such as XML,
          YAML, N-Quads, and CBOR.
                </dt>
                <dd>
          The LD-Proof format utilizes a canonicalization algorithm to generate a
          cryptographic hash that is used as an input to the cryptographic proof
          algorithm. This enables the bytes generated as the cryptographic proof to be
          compact and expressible in a variety of other syntaxes such as XML,
          YAML, N-Quads, and CBOR. JWTs are inextricably tied to the JSON syntax, 
          because JWT generation requires the use of JSON.
                </dd>
                <dt id="pf15">
          PF15: Signature is not invalidated by changes in whitespace or in the ordering 
          of property-values.          
                </dt>
                <dd>
          Since LD-Proofs utilize a canonicalization algorithm, changes in
          whitespace that does not change the meaning of the information being expressed
          has no effect on the final cryptographic hash over the information. This means
          that simple changes in whitespace formatting, such as those changes made when
          writing data to a schema-less database and then retrieving the same information
          from the same database do not cause the digital signature to fail. JWT payloads
          use base-64 encoding, which is changed by whitespace formatting though it has 
          no effect on the information expressed. This makes it challenging to use JWTs to, 
          for example, express signed data in web pages meant to be indexed by search 
          engine crawlers.
                </dd>
                <dt id="pf16">
          PF16: Designed to easily support experimental signature systems.
                </dt>
                <dd>
          The JWT format requires entries in a centralized registry through a formal 
          international standards working group in order to avoid naming collisions, so 
          it does not easily support experimental extensions. The LD-Proof format is 
          naturally extensible, through the decentralized publication of cryptographic 
          suites that are guaranteed to not conflict with other LD-Proof extensions. 
          This approach enables LD-Proof developers to easily experiment with new
          cryptographic signature mechanisms that support selective disclosure, 
          zero-knowledge proofs, post-quantum algorithms, and other innovations.
                </dd>
                <dt id="pf17">
          PF17: Supports signature chaining.
                </dt>
                <dd>
          A signature chain is an ordered set of signatures over a data payload. Use
          cases, such as cryptographic signatures applied to a notarized document,
          typically require a signature by the signing party and then an additional one
          by a notary to be made after the original signing party has made their
          signature. LD-Proofs, including LD-Signatures, natively support chains of 
          signatures. JWTs only enable a single signature over a single payload.
                </dd>
                <dt id="pf18">
          PF18: Does not require pre-processing or post-processing.
                </dt>
                <dd>
          In order to encode a <a>verifiable credential</a> or a
          <a>verifiable presentation</a> in a JWT, an extra set of steps
          is required to convert the data to and from the JWT format. Such extra
          conversion steps are not required for <a>verifiable credentials</a> and
          <a>verifiable presentations</a> protected by LD-Proofs.
                </dd>
                <dt id="pf19">
          PF19: Canonicalization does not require more than base-64 encoding.
                </dt>
                <dd>
          JWTs use a simple base-64 encoding to generate the cryptographic hash of 
          the data. LD-Proofs require a more complex canonicalization algorithm to 
          generate the cryptographic hash. The JWT approach simplifies implementation 
          but reduces encoding flexibility. The LD-Proof approach increases encoding 
          flexibility but complicates implementation.
        </dd>
      </dl>
    </section>

    <section class="informative">
      <h2>Terminology</h2>

      <div data-include="https://w3c.github.io/vc-data-model/terms.html"
        data-oninclude="restrictReferences">
      </div>
    </section>

    <section>
      <h2>Verification</h2>

      <em>This section is non-normative.</em>

      <p>
TBD
      </p>

      <section>
        <h3>Core Data Model</h3>

        <p>
Conformant tooling that processes Verifiable Credentials will ensure that
the core data model is verified when processing credentials.
        </p>
      </section>

      <section>
        <h3>Specific Verifiable Credentials</h3>

        <p>
There are many data verification languages, the following approach is one
that should work for most use cases.
        </p>
      </section>

      <section>
        <h3>Disputes</h3>

        <p>
  There are at least two different cases to consider where an <a>entity</a>
  wants to dispute a <a>credential</a> issued by an <a>issuer</a>:
        </p>

        <ul>
          <li>
  A <a>subject</a> disputes a claim made by the <a>issuer</a>. For example, the
  <code>address</code> <a>property</a> is incorrect or out of date.
          </li>
          <li>
  An <a>entity</a> disputes a potentially false claim made by the <a>issuer</a>
  about a different <a>subject</a>. For example, an imposter claims the social
  security number for an <a>entity</a>.
          </li>
        </ul>

        <p>
  The mechanism for issuing a <code>DisputeCredential</code> is the same as
  for a regular <a>credential</a>, except that the <code>credentialSubject</code>
  identifier in the <code>DisputeCredential</code> property is the identifier of
  the disputed <a>credential</a>.
        </p>

        <p>
  For example, if a <a>credential</a> with an identifier of
  <code>https://example.org/credentials/245</code> is disputed, an <a>entity</a>
  can issue one of the <a>credentials</a> shown below. In the first example, the
  <a>subject</a> might present this to the <a>verifier</a> along with the disputed
  <a>credential</a>. In the second example, the <a>entity</a> might publish the
  <code>DisputeCredential</code> in a public venue to make it known that the
  <a>credential</a> is disputed.
        </p>

        <pre class="example nohighlight" title="A subject disputes a credential">
  {
  "@context": [
    "https://www.w3.org/2018/credentials/v1",
    "https://www.w3.org/2018/credentials/examples/v1"
  ],
  "id": "http://example.com/credentials/123",
  "type": ["VerifiableCredential", "DisputeCredential"],
  <span class="highlight">"credentialSubject": {
    "id": "http://example.com/credentials/245",
    "currentStatus": "Disputed",
    "statusReason": {
      "@value": "Address is out of date",
      "@language": "en"
    },
  }</span>,
  "issuer": "https://example.com/people#me",
  "issuanceDate": "2017-12-05T14:27:42Z",
  "proof": { ... }
  }
        </pre>


        <pre class="example nohighlight" title="Another entity disputes a credential">
  {
  "@context": "https://w3id.org/credentials/v1",
  "id": "http://example.com/credentials/321",
  "type": ["VerifiableCredential", "DisputeCredential"],
  <span class="highlight">"credentialSubject": {
    "id": "http://example.com/credentials/245",
    "currentStatus": "Disputed",
    "statusReason": {
      "@value": "Credential contains disputed statements",
      "@language": "en"
    },
    "disputedClaim": {
      "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
      "address": "Is Wrong"
    }
  }</span>,
  "issuer": "https://example.com/people#me",
  "issuanceDate": "2017-12-05T14:27:42Z",
  "proof": { ... }
  }
        </pre>

  <p> In the above <a>verifiable credential</a>, the <a>issuer</a> is claiming that
  the address in the disputed <a>verifiable credential</a> is wrong. For example,
  the <a>subject</a> might wrongly be claiming to have the same address as that of
  the <a>issuer</a>.
  </p>
        <p class="note">
  If a <a>credential</a> does not have an identifier, a content-addressed
  identifier can be used to identify the disputed <a>credential</a>. Similarly,
  content-addressed identifiers can be used to uniquely identify individual
  claims.
        </p>

      </section>

    </section>

    <section>
      <h2>Extensions</h2>

      <em>This section is non-normative.</em>

      <p>
TBD
      </p>

      <section>
        <h3>Creating New Credential Types</h3>

        <ul>
          <li>
Design the Data Model.
          </li>
          <li>
Create the JSON-LD Context.
          </li>
          <li>
Select a publishing location.
          </li>
          <li>
Use the new JSON-LD Context.
          </li>
        </ul>
      </section>

      <section>
        <h3>Human Readability</h3>
        <p>
The JSON-LD Context declaration mechanism is used by implementations to
signal the context in which the data transmission is happening to consuming
applications:
        </p>

        <pre class="example nohighlight" title="Use of @context mechanism">
          {
            <span class="highlight">
            "@context": [
              "https://www.w3.org/2018/credentials/v1",
              "https://www.w3.org/2018/credentials/examples/v1"
            ]</span>,
            "id": "http://example.edu/credentials/1872",
            ...
        </pre>

        <p>
Extension authors are urged to publish two types of information at the
context URLs. The first type of information is for machines, and is the
machine-readable JSON-LD Context. The second type of information is for
humans, and should be an HTML document. It is suggested that the default
mode of operation is to serve the machine-readable JSON-LD Context as that is
the primary intended use of the URL. If content-negotiation is supported,
requests for <code>text/html</code> should result in a human readable document.
The human readable document should at least contain usage information for the
extension, such as the expected order of URLs associated with the
<code>@context</code> property, specifications that elaborate on the extension,
and examples of typical usage of the extension.
        </p>
      </section>

    </section>

    <section>
      <h2>Cryptography</h2>

      <em>This section is non-normative.</em>

      <p>
      </p>

      <section>
        <h2>Benefits of JWTs</h2>

        <p class="note">
This section will explain the benefits of using only JSON and JWTs as well as
JSON-LD and JWTs.
        </p>

      </section>

      <section>
        <h2>Benefits of JSON-LD and LD-Proofs</h2>

        <p>
The Verifiable Credentials Data Model is designed to be compatible with a
variety of existing and emerging syntaxes and digital proof formats. Each
approach has benefits and drawbacks. The following table is intended to
summarize a number of these native trade-offs.
        </p>

        <p>
The table below compares three syntax and proof format ecosystems; JSON+JWTs,
JSON-LD+JWTs, and JSON-LD+LD-Proofs. Readers should be aware that
Zero-Knowledge Proofs are currently proposed as a sub-type of LD-Proofs and
thus fall into the final column below.
        </p>

        <table class="simple">
          <thead>
            <tr>
              <th style="text-align: center;">Feature</th>
              <th style="text-align: center;">JSON<br>+<br>JWTs</th>
              <th style="text-align: center;">JSON&#8209;LD<br>+<br>JWTs</th>
              <th style="text-align: center;">JSON&#8209;LD<br>+<br>LD&#8209;Proofs</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>
<a href="#pf1">PF1.</a> Support for open world data modelling.
              </td>
              <td class="missing">✖</td>
              <td class="supported">✓</td>
              <td class="supported">✓</td>
            </tr>
            <tr>
              <td>
<a href="#pf2">PF2.</a> Universal identifier mechanism for JSON objects via
the use of URIs.
              </td>
              <td class="missing">✖</td>
              <td class="supported">✓</td>
              <td class="supported">✓</td>
            </tr>
            <tr>
              <td>
<a href="#pf3">PF3.</a> A way to disambiguate properties shared among different
JSON documents by mapping them to IRIs via a context.
              </td>
              <td class="missing">✖</td>
              <td class="supported">✓</td>
              <td class="supported">✓</td>
            </tr>
            <tr>
              <td>
<a href="#pf4">PF4.</a> A mechanism to refer to data in an external document,
where the data may be merged with the local document without a merge conflict
in semantics or structure.
              </td>
              <td class="missing">✖</td>
              <td class="supported">✓</td>
              <td class="supported">✓</td>
            </tr>
            <tr>
              <td>
<a href="#pf5">PF5.</a> The ability to annotate strings with their language.
              </td>
              <td class="missing">✖</td>
              <td class="supported">✓</td>
              <td class="supported">✓</td>
            </tr>
            <tr>
              <td>
<a href="#pf6">PF6.</a> A way to associate arbitrary datatypes, such as dates
and times, with arbitrary property values.
              </td>
              <td class="missing">✖</td>
              <td class="supported">✓</td>
              <td class="supported">✓</td>
            </tr>
            <tr>
              <td>
<a href="#pf7">PF7.</a> A facility to express one or more directed graphs,
such as a social network, in a single document.
              </td>
              <td class="missing">✖</td>
              <td class="supported">✓</td>
              <td class="supported">✓</td>
            </tr>
            <tr>
              <td>
<a href="#pf8">PF8.</a> Supports signature sets.
              </td>
              <td class="missing">✖</td>
              <td class="missing">✖</td>
              <td class="supported">✓</td>
            </tr>
            <tr>
              <td>
<a href="#pf9">PF9.</a> Embeddable in HTML such that search crawlers will
index the machine-readable content.
              </td>
              <td class="missing">✖</td>
              <td class="missing">✖</td>
              <td class="supported">✓</td>
            </tr>
            <tr>
              <td>
<a href="#pf10">PF10.</a> Data on the wire is easy to debug and serialize to
database systems.
              </td>
              <td class="missing">✖</td>
              <td class="missing">✖</td>
              <td class="supported">✓</td>
            </tr>
            <tr>
              <td>
<a href="#pf11">PF11.</a> Nesting signed data does not cause data size to
double for every embedding.
              </td>
              <td class="missing">✖</td>
              <td class="missing">✖</td>
              <td class="supported">✓</td>
            </tr>
            <tr>
              <td>
<a href="#pf12">PF12.</a> Proof format supports Zero-Knowledge Proofs.
              </td>
              <td class="missing">✖</td>
              <td class="missing">✖</td>
              <td class="supported">✓</td>
            </tr>
            <tr>
              <td>
<a href="#pf13">PF13.</a> Proof format supports arbitrary proofs such as Proof
of Work, Timestamp Proofs, and Proof of Stake.
              </td>
              <td class="missing">✖</td>
              <td class="missing">✖</td>
              <td class="supported">✓</td>
            </tr>
            <tr>
              <td>
<a href="#pf14">PF14.</a> Proofs can be expressed unmodified in other data
syntaxes such as YAML, N-Quads, and CBOR.
              </td>
              <td class="missing">✖</td>
              <td class="missing">✖</td>
              <td class="supported">✓</td>
            </tr>
            <tr>
              <td>
<a href="#pf15">PF15.</a> Changing property-value ordering, or introducing
whitespace does not invalidate signature.
              </td>
              <td class="missing">✖</td>
              <td class="missing">✖</td>
              <td class="supported">✓</td>
            </tr>
            <tr>
              <td>
<a href="#pf16">PF16.</a> Designed to easily support experimental signature
systems.
              </td>
              <td class="missing">✖</td>
              <td class="missing">✖</td>
              <td class="supported">✓</td>
            </tr>
            <tr>
              <td>
<a href="#pf17">PF17.</a> Supports signature chaining.
              </td>
              <td class="missing">✖</td>
              <td class="missing">✖</td>
              <td class="supported">✓</td>
            </tr>
            <tr>
              <td>
<a href="#pf18">PF18.</a> Does not require pre-processing or post-processing.
              </td>
              <td class="missing">✖</td>
              <td class="missing">✖</td>
              <td class="supported">✓</td>
            </tr>
            <tr>
              <td>
<a href="#pf19">PF19.</a> Canonicalization requires more than base-64 encoding.
              </td>
              <td class="supported">✓</td>
              <td class="supported">✓</td>
              <td class="missing">✖</td>
            </tr>
          </tbody>
        </table>

        <p class="note">
Some of the features listed in the table above are debateable, since a feature
can always be added to a particular syntax or digital proof format. The table
is intended to identify native features of each combination such that no
additional language design or extension is required to achieve the identified
feature. Features that all languages provide, such as the ability to express
numbers, have not been included for the purposes of brevity.
        </p>

        <dl>
          <dt id="pf1">
PF1: Support for open world data modelling
          </dt>
          <dd>
An <em>open world data model</em> is one where any entity can make any
statement about anything while simultaneously ensuring that the semantics of
the statement are unambiguous. This specification is enabled by an open world
data model called Linked Data. One defining characteristic of supporting an open
world data model is the ability to specify the semantic context in which data
is being expressed. JSON-LD provides this mechanism via the
<code>@context</code> property. JSON has no such feature.
          </dd>
          <dt id="pf2">
PF2: Universal identifier mechanism for JSON objects via the use of URIs.
          </dt>
          <dd>
All entities in a JSON-LD document are identified either via an automatic URI,
or via an explicit URI. This enables all entities in a document to be
unambiguously referenced. JSON does not have a native URI type nor does it
require objects to have one, making it difficult to impossible to unambiguously
identify an entity expressed in JSON.
          </dd>
          <dt id="pf3">
PF3: A way to disambiguate properties shared among different JSON documents by
mapping them to IRIs via a context.
          </dt>
          <dd>
All object properties in a JSON-LD document, such as the property "homepage",
are either keywords or they are mapped to an IRI. This feature enables open
world systems to identify the semantic meaning of the property in an unambiguous
way, which enables seamless merging of data between disparate systems.
JSON object properties are not mapped to IRIs, which result in ambiguities with
respect to the semantic meaning of the property. For example, one JSON document
might use "title" (meaning "book title") in a way that is semantically
incompatible with another JSON document using "title" (meaning "job title").
          </dd>
          <dt id="pf4">
PF4: A mechanism to refer to data in an external document, where the data may
be merged with the local document without a merge conflict in semantics or
structure.
          </dt>
          <dd>
JSON-LD provides a mechanism that enables a data value to use a URL to refer
to data outside of the local document. This external data may then be
automatically merged with the local document without a merge conflict in
semantics or structure. This feature enables a system to apply the
"follow your nose" principle to discover a richer set of data that is
associated with the local document. While a JSON document can contain pointers
to external data, interpreting the pointer is often application specific and
usually does not support merging the external data to construct a richer data
set.
          </dd>
          <dt id="pf5">
PF5: The ability to annotate strings with their language.
          </dt>
          <dd>
JSON-LD enables a developer to specify the language, such as English, French,
or Japanese, in which a text string is expressed via the use of language tags.
JSON does not provide such a feature.
          </dd>
          <dt id="pf6">
PF6: A way to associate arbitrary datatypes, such as dates
and times, with arbitrary property values.
          </dt>
          <dd>
JSON-LD enables a developer to specify the data type of a property value,
such as Date, unsigned integer, or Temperature by specifying it in the
JSON-LD Context. JSON does not provide such a feature.
          </dd>
          <dt id="pf7">
PF7: A facility to express one or more directed graphs, such as a social
network, in a single document.
          </dt>
          <dd>
JSON-LD's abstract data model supports the expression of information
as a directed graph of labeled nodes and edges, which enables an open world
data model to be supported. JSON's abstract data model only supports the
expression of information as a tree of unlabeled nodes and edges, which
restricts the types of relationships and structures that can be natively
expressed in the language.
          </dd>
          <dt id="pf8">
PF8: Supports signature sets.
          </dt>
          <dd>
A signature set is an unordered set of signatures over a data payload. Use
cases, such as cryptographic signatures applied to a legal contract,
typically require more than one signature to be associated with the contract
in order to legally bind two or more parties under the terms of the contract.
Linked Data Proofs, including Linked Data Signatures, natively support sets of
signatures. JWTs only enable a single signature over a single payload.
          </dd>
          <dt id="pf9">
PF9: Embeddable in HTML such that search crawlers will index the
machine-readable content.
          </dt>
          <dd>
All major search crawlers natively parse and index information expressed as
JSON-LD in HTML pages. LD-Proofs enable the current data format that search
engines use to be extended to support digital signatures. JWTs have no mechanism
to express data in HTML pages and are currently not indexed by search crawlers.
          </dd>
          <dt id="pf10">
PF10: Data on the wire is easy to debug and serialize to database systems.
          </dt>
          <dd>
When developers are debugging software systems, it is beneficial for them to be
able to see the data that they are operating on using common debugging tools.
Similarly, it is useful to be able to serialize data from the network to a
database and then from the database back out to the network using a minimal
number of pre and post processing steps. LD-Proofs enable developers to use
common JSON tooling without having to convert the format into a different
format or structure. JWTs base-64 encode payload information, resulting in
complicated pre and post processing steps to convert the data into JSON data
while not destroying the digital signature. Similarly, schema-less databases,
which are typically used to index JSON data, cannot index information
that is expressed in an opaque base-64 encoded wrapper.
          </dd>
          <dt id="pf11">
PF11: Nesting signed data does not cause data size to double for every
embedding.
          </dt>
          <dd>
When a JWT is encapsulated by another JWT, the entire payload must be base-64
encoded in the initial JWT, and then base-64 encoded again in the encapsulating
JWT. This is often necessary when a cryptographic signature is required on a
document that contains a cryptographic signature, such as when a Notary
signs a document that has been signed by someone else seeking the Notary's
services. LD-Proofs do not require base-64 encoding the signed portion of a
document and instead rely on a canonicalization process that is just as
secure, and that only requires the cryptographic signature to be encoded
instead of the entire payload.
          </dd>
          <dt id="pf12">
PF12: Proof format supports Zero-Knowledge Proofs.
          </dt>
          <dd>
The LD-Proof format is capable of modifying the algorithm that generates
the hash or hashes that are cryptographically signed. This cryptographic
agility enables digital signature systems, such as Zero-Knowledge Proofs,
to be layered on top of LD-Proofs instead of an entirely new digital signature
container format to be created. JWTs are designed such that an entirely new
digital signature container format will be required to support Zero-Knowledge
Proofs.
          </dd>
          <dt id="pf13">
PF13: Proof format supports arbitrary proofs such as Proof of Work, Timestamp
Proofs, and Proof of Stake.
          </dt>
          <dd>
The LD-Proof format was designed with a broader range of proof types in mind
and supports cryptographic proofs beyond simple cryptographic signatures.
These proof types are in common usage in systems such as decentralized ledgers
and provide additional guarantees to
<a>verifiable credentials</a>, such as the ability to prove that a particular
claim was made at a particular time or that a certain amount of energy was
expended to generate a particular credential. The JWT format does not support
arbitrary proof formats.
          </dd>
          <dt id="pf14">
PF14: Proofs can be expressed unmodified in other data syntaxes such as XML,
YAML, N-Quads, and CBOR.
          </dt>
          <dd>
The LD-Proof format utilizes a canonicalization algorithm to generate a
cryptographic hash that is used as an input to the cryptographic proof
algorithm. This enables the bytes generated as the cryptographic proof to be
compact and expressible in a variety of other syntaxes such as XML,
YAML, N-Quads, and CBOR. Since JWTs require the use of JSON to be generated,
they are inextricably tied to the JSON syntax.
          </dd>
          <dt id="pf15">
PF15: Changing property-value ordering, or introducing whitespace does not
invalidate signature.
          </dt>
          <dd>
Since LD-Proofs utilize a canonicalization algorithm, the introduction of
whitespace that does not change the meaning of the information being expressed
has no effect on the final cryptographic hash over the information. This means
that simple changes in whitespace formatting, such as those changes made when
writing data to a schema-less database and then retrieving the same information
from the same database do not cause the digital signature to fail. JWTs
encode the payload using the base-64 format which is not resistant to
whitespace formatting that has no effect on the information expressed. This
shortcoming of JWTs make it challenging to, for example, express signed data in
web pages that search crawlers index.
          </dd>
          <dt id="pf16">
PF16: Designed to easily support experimental signature systems.
          </dt>
          <dd>
The LD-Proof format is naturally extensible, not requiring the format to be
extended in a formal international standards working group in order to
prevent namespace collisions. The JWT format requires entries in a centralized
registry in order to avoid naming collisions and does not support
experimentation as easily as the LD-Proof format does. LD-Proof format
extension is done through the decentralized publication of cryptographic
suites that are guaranteed to not conflict with other LD-Proof
extensions. This approach enables developers to easily experiment with new
cryptographic signature mechanisms that support selective disclosure,
zero-knowledge proofs, and post-quantum algorithms.
          </dd>
          <dt id="pf17">
PF17: Supports signature chaining.
          </dt>
          <dd>
A signature chain is an ordered set of signatures over a data payload. Use
cases, such as cryptographic signatures applied to a notarized document,
typically require a signature by the signing party and then an additional one
by a notary to be made after the original signing party has made their
signature. Linked Data Proofs, including Linked Data Signatures, natively
support chains of signatures. JWTs only enable a single signature over a
single payload.
          </dd>
          <dt id="pf18">
PF18: Does not require pre-processing or post-processing.
          </dt>
          <dd>
In order to encode a <a>verifiable credential</a> or a
<a>verifiable presentation</a> in a JWT, an extra set of steps
are required to convert the data to and from the JWT format. No such extra
converstion step are required for <a>verifiable credentials</a> and
<a>verifiable presentations</a> protected by LD-Proofs.
          </dd>
          <dt id="pf19">
PF19: Canonicalization requires more than base-64 encoding.
          </dt>
          <dd>
The JWT format utilizes a simple base-64 encoding format to generate the
cryptographic hash of the data. The encoding format for LD-Proofs require
a more complex canonicalization algorithm to generate the cryptographic
hash. The benefits of the JWT approach are simplicity at the cost of
encoding flexibility. The benefits of the LD-Proof approach are flexibility at
the cost of implementation complexity.
          </dd>
        </dl>
        <p>
The Verifiable Credentials Data Model is designed to be compatible with a
variety of existing and emerging digital proof formats. Each
proof format has benefits and drawbacks. For instance, many proof formats
cannot reveal selected attribute values in a verifiable credential;
they can only reveal all (or none).
        </p>
        <p>
Zero-Knowledge Proofs (ZKPs) are a proof format that enables
privacy-preserving and data-minimization features in
verifiable presentations, such as selective disclosure and predicate proofs.
        </p>
        <p>
Selective disclosure is the ability of a holder to reveal a subset of
the attributes of a verifiable credential in a verifiable presentation.
A presentation based on zero-knowledge proof mechanisms only contains
those attributes and associated values that are required to satisfy
the presentation requirements. 
        </p>
        <p>
Zero-knowledge predicate proofs are a type of proof associated with
an attribute. Predicate proofs include comparisons, such as
"greater than", "less than", "not equal", "range", 
"set membership", and "set non-membership".
Predicate proofs can be constructed without requiring the issuer
to create special fields, such as
"age-under-18", "age-over-21", or "age-over-60", in the verifiable credential
at the time the credential was issued.
For example, if a holder has a credential with a "birth-date" claim,
the holder can create a predicate proof based on "birth-date" in the
verifiable presentation. A predicate value derived from "birth-date" in
the verifiable credential can cryptographically prove to the verifier that
the holder's age is greater (or less) than a specified number, without
revealing the holder's "birth-date".
        </p>
        <p>
Verifiable credentials based on zero-knowledge proof mechanisms are
also quantum-resistant after presentation.
        </p>
        <p>
A drawback of zero-knowledge proof mechanisms is that they are
more complex and larger than some older signature schemes.
        </p>
      </section>

      <section>
        <h3>Cryptographic Suites</h3>

        <ul>
          <li>
            Design the Cryptographic Suite.
          </li>
          <li>
            Create the JSON-LD Context.
          </li>
          <li>
            Select a publishing location.
          </li>
          <li>
            Implement the Cryptographic Suite and use it.
          </li>
        </ul>
      </section>

      <section>
        <h3>COSE Signature Expression</h3>

        <p>
          Use COSE to express signature values.
        </p>
      </section>

      <section>
        <h3>COSE Key Expression</h3>

        <p>
          Use COSE Web Keys to express key material.
        </p>
      </section>

      <section>
        <h3>Hashlinks</h3>

        <p>
          Hashlink URLs can be used to provide content integrity for links to 
          external resources.
        </p>
      </section>

    </section>

    <section>
      <h2>Progressive Trust</h2>
      <em>This section is non-normative.</em>

      <p>
Entities that use <a>verifiable credentials</a> and
<a>verifiable presentations</a> should follow protocols that enable progressive
trust. Progressive trust refers to enabling individuals to share information
about themselves only on an as needed basis, slowing building up more trust as
more information is shared with another party.
      </p>
      <p>
Progressive trust is strongly related to the principle of data minimization, and
enabled by technologies such as selective disclosure and predicate proofs. We
encourage the use of progressive trust as a guiding principle for implementers
as they develop protocols for <a>issuers</a>, <a>holders</a>, and
<a>verifiers</a>.

      </p>

      <section>
        <h3>Data Minimization</h3>
        <p>
Data minimization is a principle that encourages <a>verifiers</a> to request the
minimum amount of data necessary from <a>holders</a>, and for <a>holders</a> to
only provide the minimum amount of data to <a>verifiers</a>. This "minimum
amount of data" depends on the situation and may change over the course of a
<a>holder</a>'s interaction with a <a>verifier</a>.
        </p>
        <p>
For example, a <a>holder</a> may apply for a loan, with a bank acting as the
<a>verifier</a>. There are several points at which the bank may want to determine
whether the <a>holder</a> is qualified to continue in the process of applying for
the loan; for instance, the bank may have a policy of only providing loans to
existing account holders. A protocol that follows the principle of data
minimization would allow the <a>holder</a> to reveal to the <a>verifier</a> only
that they are an existing account holder, before the bank requests any additional
information, such as account balances or employment status. In this way, the
applicant may progressively entrust the bank with more information, as the data
needed by the bank to make its determinations is requested a piece at a time, as
needed, rather than as a complete set, up front.
        </p>
      </section>

      <section>
        <h3>Selective Disclosure</h3>

        <p>
Selective disclosure is the ability of a <a>holder</a> to select some elements
of a <a>verifiable credential</a> to share with a <a>verifier</a>, without
revealing the rest. There are several different methods which support selective
disclosure, we provide two examples:
        </p>
        <ul>
          <li>
<b>Atomic Credentials</b> - These are <a>verifiable credentials</a> which
consist of a single claim. An <a>issuer</a> may provide a set of atomic
credentials that duplicates the claims of a standard credential. This atomicity
allows a <a>holder</a> to disclose only those claims which need to be revealed
to a <a>verifier</a>, rather than requiring all of the claims of a standard
credential to be revealed.
          </li>
          <li>
<b>Selective Disclosure Signatures</b> - Certain signature schemes natively
support selective disclosure of <a>verifiable credential</a> claims. One
example of these is
<a href="https://groups.csail.mit.edu/cis/pubs/lysyanskaya/cl02b.pdf">Camenisch-Lysyanskaya
signatures</a>. Such Signatures allow a <a>holder</a> to disclose only those
claims which need to be revealed to a <a>verifier</a>, rather than requiring
all of the credential's claims to be revealed.

          </li>
        </ul>
        <p>

        </p>

      </section>
      <section>
        <h3>Predicates</h3>
        <p>
Another technique which may be used to support progressive trust is to use
predicates as the values of revealed claims. Predicates allow a <a>holder</a> to
provide True/False values to a <a>verifier</a> rather than revealing claim
values.
        </p>
        <p>
Predicate proofs may be enabled by <a>verifiable credential</a> <a>issuers</a>
as claims, e.g., the <a>credentialSubject</a> may include an
<code>ageOver18</code> <a>property</a> rather than a <code>birthdate</code>
<a>property</a>. This would allow <a>holders</a> to provide proof that they are
over 18 without revealing their birthdates.
        </p>
        <p>
Certain signature types enable predicate proofs by allowing claims from a
standard <a>verifiable credential</a> to be presented as predicates. For
example, a <a href="https://groups.csail.mit.edu/cis/pubs/lysyanskaya/cl02b.pdf">
Camenisch-Lysyanskaya signed</a> <a>verifiable credential</a> that contains a
<code>credentialSubject</code> with a <code>birthdate</code> <a>property</a> may
be included in a <a>verifiable presentation</a> as a derived credential that
contains an <code>ageOver18</code> <a>property</a>.
        </p>
      </section>
      <section>
        <h3>Further Techniques</h3>
        <p>
The examples provided in this section are intended to illustrate some possible
mechanisms for supporting progressive trust, not provide an exhaustive or
comprehensive list of all the ways progressive trust may be supported. Research
in this area continues with the use of cutting-edge proof techniques such as
<a href="https://z.cash/technology/zksnarks/">zk-SNARKS</a> and
<a href="https://crypto.stanford.edu/bulletproofs/">Bulletproofs</a>, as well as
different signature protocols.
        </p>
        <p>
A draft report by the <a href="https://www.w3.org/community/credentials/">
Credentials Community Group</a> on
<a href="https://w3c-ccg.github.io/data-minimization/">data minimization</a> may
also be useful reading for implementers looking to enable progressive trust.
        </p>
      </section>
    </section>

    <section>
      <h2>Test suite</h2>

      <em>This section is non-normative.</em>

      <p>
        The W3C Verifiable Claims Working Group has produced a 
        <a href="https://github.com/w3c/vc-test-suite/">test suite</a> in order 
        for implementers to validate their conformance with the current specifications. 
        Any conforming implementation MUST pass all tests in the test suite.
      </p>
      <p>
        You can review the <a href="https://w3c.github.io/vc-test-suite/implementations/">current 
        draft implementation report</a>, which contains conformance testing results for submitted
        implementations supporting the Verifiable Credentials Data Model specification.
      </p>
    </section>
  
  </body>
</html>
